%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MUW Presentation
% LaTeX Template
% Version 1.0 (27/12/2016)
%
% License:
% CC BY-NC-SA 4.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
% Created by:
% Nicolas Ballarini, CeMSIIS, Medical University of Vienna
% nicoballarini@gmail.com
% http://statistics.msi.meduniwien.ac.at/
%
% Customized for UAH by:
% David F. Barrero, Departamento de Automática, UAH
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[10pt,compress]{beamer} % Change 10pt to make fonts of a different size
\mode<presentation>

\usepackage[spanish]{babel}
\usepackage{fontspec}
\usepackage{tikz}
\usepackage{etoolbox}
\usepackage{xcolor}
\usepackage{xstring}
\usepackage{listings}
\usepackage{multicol}
\usepackage{tikz}
\usetikzlibrary{matrix,chains,positioning,decorations.pathreplacing,arrows,shapes}

\usetheme{UAH}
\usecolortheme{UAH}
\setbeamertemplate{navigation symbols}{} 
\setbeamertemplate{caption}[numbered]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Presentation Info
\title[Scientific Programming]{Scientific Programming in Python}
\author{\asignatura\\\carrera}
\institute{}
\date{Departamento de Automática}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Descomentar para habilitar barra de navegación superior
\setNavigation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Configuración de logotipos en portada
%% Opacidad de los logotipos
\newcommand{\opacidad}{1}
%% Descomentar para habilitar logotipo en pié de página de portada
\renewcommand{\logoUno}{Images/isg.png}
%% Descomentar para habilitar logotipo en pié de página de portada
%\renewcommand{\logoDos}{Images/CCLogo.png}
%% Descomentar para habilitar logotipo en pié de página de portada
%\renewcommand{\logoTres}{Images/ALogo.png}
%% Descomentar para habilitar logotipo en pié de página de portada
%\renewcommand{\logoCuatro}{Images/ELogo.png}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FOOTLINE
%% Comment/Uncomment the following blocks to modify the footline
%% content in the body slides. 


%% Option A: Title and institute
\footlineA
%% Option B: Author and institute
%\footlineB
%% Option C: Title, Author and institute
%\footlineC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Use this block for a blue title slide with modified footline
{\titlepageBlue
    \begin{frame}
        \titlepage
    \end{frame}
}

\begin{frame}[plain]{}
	\begin{block}{Objectives}
		\begin{enumerate}
		\item Introduce some Python tools for scientific programming.
		\item Motivate the need of efficient matrix manipulation.
		\item Handle matrices and dataframes in Python.
		\item Basic data visualization with Python.
		\end{enumerate}
	\end{block}

   \begin{block}{Bibliography}
       Jake VanderPlas. \textit{Python Data Science Handbook}. Chapters 1, 2, 3 and 4. O'Reilly. \href{https://jakevdp.github.io/PythonDataScienceHandbook/}{(Link)}.
   \end{block}

\end{frame}

{
\disableNavigation{white}
\begin{frame}[shrink]{Table of Contents}
 \frametitle{Table of Contents}
 \begin{multicols}{2}
 \tableofcontents
 \end{multicols}
  % You might wish to add the option [pausesections]
\end{frame}
}

\section{Overview}

\subsection{Data Science}

\begin{frame}{Overview}{Data Science}
	\begin{figure}
		\includegraphics[scale=0.35]{figs/Data_Science_VD.png}	
	\end{figure}				
\end{frame}

\subsection{The data scientist toolkit}

\begin{frame}{Data Science}{The data scientist tookit (I)}
	Data science is about manipulating data
	\begin{itemize}
		\item Need of specialized tools
		\item Two main languajes: R and Python
	\end{itemize}
	Python is a general purpose programming language
	\begin{itemize}
		\item Easy integration 
		\item Huge ecosystem of packages and tools
	\end{itemize}
	Need of data-oriented tools
	\begin{itemize}
		\item Features provided by third-party tools
	\end{itemize}

\end{frame}

\begin{frame}{Data Science}{The data scientist tookit (II)}
   \begin{tabular}{cll}\hline
       \textbf{Tool}& \textbf{Type} & \textbf{Description}\\ \hline
	   \texttt{iPython} & Software & Advaced Python interpreter \\
	   \texttt{Jupiter} & Software & Python notebooks (Python interpreter) \\
	   \texttt{Numpy}   & Package  & Efficient array operations \\
	   \texttt{Pandas}  & Package  & Dataframe support \\
	   \texttt{Matplotlib} & Package & Data visualization \\
	   \texttt{Seaborn} & Package & Data visualization with dataframes \\
	   \texttt{Scikit-learn} & Package & AI/ML package for Python \\
	   \hline
   \end{tabular}
\end{frame}

\subsection{Anaconda}
\begin{frame}{Data Science}{Anaconda}
    \begin{columns}
 	   \column{.6\textwidth}
   All those tools are packaged in \texttt{Anaconda}
   \begin{itemize}
   		\item Python distribution for Data Science
	\end{itemize}

	Anaconda provides \texttt{Spyder}
	\begin{itemize}
		\item Python IDE designed for Data Science
	\end{itemize}

	Other tools provided by Anaconda
	\begin{itemize}
		\item Conda: Packages management tool
		\item TensorFlow: Deep Learning 
		\item Many others
	\end{itemize}

 		\column{.4\textwidth}
			\includegraphics[width=0.6\textwidth]{figs/Anaconda_Logo.png} \\\bigskip
			\includegraphics[width=0.6\textwidth]{figs/spyder.png}	
			%\includegraphics[width=0.6\textwidth]{figs/spyder-ide.png}	
	\end{columns}
\end{frame}

\subsection{Python IDEs for Data Science}
\begin{frame}{Data Science}{Python IDEs for Data Science (I)}
    \begin{columns}[t]
 	   \column{.25\textwidth}
	   \centering \textbf{iPython}\\
	   iPython = Interactive Python
   		\begin{itemize}
		\item Extended funcionality
		\item Enhanced UI
		\item External editor
		\end{itemize}

		Running iPython:\\
		\texttt{\$ ipython}

 	   \column{.25\textwidth}
	   \centering \textbf{Jupyter}\\
		Python notebooks
	\begin{itemize}
		\item Web-based IDE
		\item Documentation
		\item Integration with GitHub
		\item Uses iPython
	\end{itemize}

		Running Jupyter:\\
		\texttt{\$ jupyter notebook}

		\includegraphics[width=0.8\textwidth]{figs/jupyter.png}	

 	\column{.25\textwidth}
	   \centering \textbf{Rodeo}\\
		Python version of RStudio
		\begin{itemize}
			\item Good for R developers
			\item Not included in Anaconda
			\item Uses iPython
		\end{itemize}
        
        \bigskip

		\includegraphics[width=0.8\textwidth]{figs/rodeo.png}	

 	\column{.25\textwidth}
	   \centering \textbf{Spyder}\\
		Matlab-like IDE

        \bigskip

		\includegraphics[width=0.8\textwidth]{figs/spyder-ide.png}	

	\end{columns}
\end{frame}

\begin{frame}{Data Science}{Python IDEs for Data Science (II)}
    \begin{block}{Exercises}
		Write a Python script that shows the multiplication table of the number 5. Write the script using each one of the following environments:
   		\begin{enumerate}
   		\item iPython + text editor of your choice.
		\item Jupiter. 
            \begin{itemize}
                \item Bonus track: Publish the notebook in GitHub.
            \end{itemize}
		\item Spyder.
		\item Rodeo.
		\end{enumerate}
	\end{block}
\end{frame}

\section{Basics}
\begin{frame}{iPython}{Basics (I)}
    In regular Python ...
    \begin{itemize}
        \item most objects come with a docstring attribute
        \item docstring accesible thorugh \texttt{help()}
    \end{itemize}
    iPython provides `\texttt{?}', a shortcut to \texttt{help()}
    \begin{itemize}
        \item \texttt{len?}, \texttt{list?}, \texttt{list.append?}
        \item Try to type just `\texttt{?}'
    \end{itemize}
    Easy access to source code with `\texttt{??}'
    \begin{itemize}
        \item Does not work with most buildin functions!
    \end{itemize}
\end{frame}

\begin{frame}{iPython}{Basics (II)}
    Press \texttt{<tab>} to complete almost everything
    \begin{itemize}
        \item Object contents\\
	\includegraphics[width=0.45\textwidth]{figs/tab.png} 
        \item Packages\\
	\includegraphics[width=0.36\textwidth]{figs/tab2.png}	
        \item Wildcards\\
	\includegraphics[width=0.45\textwidth]{figs/tab3.png}	
    \end{itemize}
\end{frame}

\begin{frame}{iPython}{Basics (III): Keyboard shortcuts}
    \footnotesize{
        Navigation\\
        \begin{tabular}{ll}\hline
       \textsc{Keystroke} &  \textsc{Action}\\ \hline
	   \texttt{Ctrl-a} & Move cursor to the beginning of the line  \\
	   \texttt{Ctrl-e} & Move cursor to the end of the line  \\
	   \texttt{Ctrl-b} & Move cursor back one character  \\
	   \texttt{Ctrl-f} & Move cursor forward one character  \\\hline
        \end{tabular}

    \bigskip
     History\\
       \begin{tabular}{ll}\hline
       \textsc{Keystroke} &  \textsc{Action}\\ \hline
       \texttt{Ctrl-p ($\uparrow$)} & Previous command  \\
       \texttt{Ctrl-n ($\downarrow$)} & Next command  \\
	   \texttt{Ctrl-r} & Reverse-search  \\\hline
    \end{tabular}

    \bigskip
        Text entry\\
        \begin{tabular}{ll}\hline
       \textsc{Keystroke} &  \textsc{Action}\\ \hline
	   \texttt{Ctrl-d} & Delete next character in line  \\
	   \texttt{Ctrl-k} & Cut text from cursor to end of line  \\
	   \texttt{Ctrl-u} & Cut text from beginning of line to cursor  \\
       \texttt{Ctrl-y} & Yank (paste) previously cut text  \\\hline
       \end{tabular}
   }
\end{frame}

\subsection{Magic commands}
\begin{frame}{iPython}{iPython magic commands}
	Magic commands: iPython extension of Python syntax
	\begin{itemize}
	\item Not valid in regular Python
	\item Provides handly features
	\item Widely used in DS and ML
	\end{itemize}
	Two flavours
	\begin{itemize}
	\item \% prefix: Line magics - single line
	\item \%\% prefix: Cell magics - several lines
	\end{itemize}
	Help available
	\begin{itemize}
		\item \texttt{\%magic}: Magic commands
		\item \texttt{\%lsmagic}: List of magic commands
	\end{itemize}
\end{frame}

\subsection{Pasting code blocks}
\begin{frame}[fragile]{iPython}{Pasting code blocks: \texttt{\%paste} and \texttt{\%cpaste}}
    \begin{columns}
 	   \column{.5\textwidth}
	   Pasting code in Python is troublesome
		\begin{itemize}
			\item \texttt{\%paste}: Paste one time
			\item \texttt{\%\%cpaste}: Paste several times
		\end{itemize}
 	   \column{.5\textwidth}
	       %\begin{block}{}
		   %    \vspace{-0.2cm}
		   %    \lstinputlisting{code/donothing.py}
		   %    \vspace{-0.2cm}
		   %\end{block}
	   \begin{exampleblock}{}
	   \vspace{-0.2cm}
		\begin{lstlisting}
def donothing(x):
    return x
		\end{lstlisting}
	   \vspace{-0.2cm}
	   \end{exampleblock}

	   \vspace{-0.2cm}
	\end{columns}

	\footnotesize{
    \begin{columns}
 	   \column{.4\textwidth}
		 \begin{exampleblock}{\footnotesize{\%paste}}
	   \vspace{-0.2cm}
	   \begin{verbatim}
In [20]: %paste
   def donothing(x):
 	  return x

## -- End pasted text --
\end{verbatim}
	   \vspace{-0.2cm}
	   \end{exampleblock}

	   \vspace{-0.2cm}

 	   \column{.6\textwidth}

	 	\begin{exampleblock}{\footnotesize{\%cpaste}}
	   \vspace{-0.2cm}
	   \begin{verbatim}
In [25]: %cpaste
Pasting code; enter '--' alone on the line
to stop or use Ctrl-D.
:       def donothing(x):
            return x:
:--
	   \end{verbatim}
	   \vspace{-0.2cm}
	   \end{exampleblock}
	   \end{columns}
	   }
\end{frame}

\subsection{Running external code}
\begin{frame}[fragile]{iPython}{Running external code: \texttt{\%run} and \texttt{\%timeit}}
    \begin{columns}
 	   \column{.4\textwidth}
	   \texttt{\%run}: Execute script
		\begin{itemize}
			\item Many optional arguments
			\item Checkout \texttt{\%run?}
		\end{itemize}
		\footnotesize{
	   \begin{exampleblock}{}
	   \vspace{-0.2cm}
	   \begin{verbatim}
In [40]: %run donothing.py

In [41]: donothing(10)
Out[41]: 10
	   \end{verbatim}
	   \vspace{-0.2cm}
	   \end{exampleblock}
		}

 	   \column{.6\textwidth}
	   \texttt{\%timeit}: Computes execution time
		\begin{itemize}
			\item Executes a single line
			\item Automatic adjustment of runs
			\item Shows basic statistics
		\end{itemize}

		\footnotesize{
	   \begin{exampleblock}{}
	   \vspace{-0.2cm}
	   \begin{verbatim}
In [33]: %timeit [n ** 2 for n in range(200)]
71.6 µs ± 1.84 µs per loop 
(mean ± std. dev. of 7 runs, 10000 loops each)

In [34]: %timeit [n ** 2 for n in range(2000)]
753 µs ± 16.2 µs per loop 
(mean ± std. dev. of 7 runs, 1000 loops each)
\end{verbatim}
	   \vspace{-0.2cm}
	   \end{exampleblock}
		}

		\normalsize{
	   \texttt{\%\%timeit}: Several lines\\
	   }
	\end{columns}

\end{frame}

\subsection{Input and output history}
\begin{frame}[fragile]{iPython}{Input and output history (I)}
	\begin{columns}
 	   \column{.6\textwidth}
	iPython stores its history as objects
	\begin{itemize}
		\item \texttt{In}: Input commands
			\begin{itemize}
			\item List storing commands
			\end{itemize}
		\item \texttt{Out}: Commands output
			\begin{itemize}
			\item Dictionary storing outputs
			\item Not all commands have outputs
			\end{itemize}
	\end{itemize}

	\vspace{-0.2cm}

 	   \column{.4\textwidth}
	\begin{exampleblock}{}
In [1]: import math

In [2]: math.sin(2)

Out[2]: 0.9092974268256817

In [3]: math.cos(2)

Out[3]: -0.4161468365471424

In [4]: Out[2] ** 2 + Out[3] ** 2

Out[4]: 1.0
	\end{exampleblock}
	\end{columns}
\end{frame}

\begin{frame}{iPython}{Input and output history (II)}
	Fast access to history: Underscore (\_)
	\begin{itemize}
		\item Variable containing the last output
		\item Example: \texttt{print(\_)}
	\end{itemize}
	Double and triple underscores
	\begin{itemize}
		\item Example: \texttt{print(\_\_)}
		\item Example: \texttt{print(\_\_\_)}
	\end{itemize}
	Trick: Shortcut to access ($\_n$)
	\begin{itemize}
		\item Out[n] = \_n, with n=number
		\item Example: \texttt{print(\_2)}
	\end{itemize}
	Magic command to show history
		\begin{itemize}
		\item \texttt{\%history}
		\end{itemize}
	Supressing command output (\texttt{;})
		\begin{itemize}
		\item Example: \texttt{4 * 2;}
		\end{itemize}
\end{frame}

\subsection{iPython shell commands}
\begin{frame}{iPython}{iPython shell commands}
	iPython provides easy interaction with the shell
	\begin{itemize}
		\item Execution of shell commands from iPython
		\item Use prefix `\texttt{!}'
		\item Example: \texttt{!ls}, \texttt{!pwd}
	\end{itemize}
	Save shell output in Python variables
	\begin{itemize}
		\item Example: \texttt{files = !ls}
	\end{itemize}
	Use Python variables in shell
	\begin{itemize}
		\item Example: \texttt{!echo \{files\}}
	\end{itemize}
\end{frame}

\subsection{Automagic}

\begin{frame}[fragile]{iPython}{Automagic}
	\begin{columns}
 	   \column{.4\textwidth}
	Problems with some shell commands
	\begin{exampleblock}{}
In [23]: !pwd

/repositorios/pythonCourse


In [24]: !cd ..


In [25]: !pwd

/repositorios/pythonCourse
	\end{exampleblock}
	Some magic commands here to help
	\begin{itemize}
		\item \texttt{\%cd}, \texttt{\%ls}, \texttt{\%mkdir}, \texttt{\%pwd}, ...
	\end{itemize}

 	   \column{.4\textwidth}
	Those magics are regularly used ...
	\begin{itemize}
		\item ... so common that \% is no longer required (automagic)
		\item Working with iPython is almost like working with a Unix-like shell
	\end{itemize}
	\footnotesize{
	\begin{block}{\footnotesize{Automagic commands}}
\texttt{cat}, \texttt{cp}, \texttt{env}, \texttt{ls}, \texttt{man}, \texttt{mkdir}, \texttt{more}, \texttt{mb}, \texttt{pwd}, \texttt{rm} and \texttt{rmdir}
	\end{block}
	}
	\end{columns}

\end{frame}

\section{NumPy}
\subsection{Understanding Data Types in Python}

\begin{frame}{NumPy}{Understanding Data Types in Python (I)}
    %Python supports matrices by default
    %\begin{itemize}
    %    \item Why do we need additional support?
	%\end{itemize}

    \begin{columns}
 	   \column{0.5\textwidth}
			
			\begin{block}{\footnotesize{Static typing}}
			\vspace{-0.2cm} 
				\lstinputlisting[basicstyle=\ttfamily\scriptsize,language=C]{code/static.c}
			\vspace{-0.2cm} 
			\end{block}

			\begin{itemize}
				\item Data types must be declared
				\item Data types cannot change
				\item Error detection in compilation
				\item Variables names are, basicly, labels
			\end{itemize}
			
 	   \column{0.5\textwidth}
			\begin{block}{\footnotesize{Dynamic typing}}
			\vspace{-0.2cm} 
				\lstinputlisting[basicstyle=\ttfamily\scriptsize]{code/dynamic.py}
			\vspace{-0.2cm} 
			\end{block}

			\begin{itemize}
				\item Data types are not declared
				\item Data types can change
				\item Error detection in run-time
				\item Variables are complex data structures (even for simple types)
			\end{itemize}
	\end{columns}
\end{frame}

\begin{frame}{NumPy}{Understanding Data Types in Python (II)}
    %Python supports matrices by default
    %\begin{itemize}
    %    \item Why do we need additional support?
	%\end{itemize}

	Dynamic typing must be implemented somewhere ...

    \begin{columns}
 	   \column{0.5\textwidth}
			\begin{block}{\footnotesize{Python 3.4 source code}}
			\vspace{-0.2cm} 
				\lstinputlisting[basicstyle=\ttfamily\scriptsize, language=C]{code/long.c}
			\vspace{-0.2cm} 
			\end{block}

 	   \column{0.5\textwidth}
			\includegraphics[width=\textwidth]{figs/cint_vs_pyint.png}	
	\end{columns}

\end{frame}

\begin{frame}[fragile]{NumPy}{Understanding Data Types in Python (III)}
	\begin{columns}
 	   \column{0.5\textwidth}
			A Python list may contain different types

 	   \column{0.5\textwidth}
	   \begin{exampleblock}{}
			\vspace{-0.2cm} 
			\lstinputlisting[basicstyle=\ttfamily\scriptsize]{code/lists.txt}
			\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}

	\bigskip

	\centering \includegraphics[width=0.8\textwidth]{figs/array_vs_list.png}	
\end{frame}

\begin{frame}[fragile]{NumPy}{Understanding Data Types in Python (IV)}
	Standard Python data types are powerful and flexible
	\begin{itemize}
		\item Flexibility has a price: Reduced performance
		\item Not an big issue in generic programming
		\item A big issue in scientific programming
		\item We require efficient data manipulation mechanisms: NumPy
	\end{itemize}
	NumPy: Python package for numeric computation
	\begin{itemize}
		\item Efficient array implementation
		\item Fast mathematical functions
		\item Random numbers generation
		\item Static data types: Less flexibility
	\end{itemize}
	Most Python modules for AI/ML depend on NumPy, in particular
	\begin{itemize}
		\item Pandas (dataframes), Scikit-learn (ML), Seaborn (data visualization)
	\end{itemize}
\end{frame}

\subsection{Introduction}
\begin{frame}[fragile]{NumPy}{Introduction}
	\begin{columns}
 	   \column{0.6\textwidth}
		NumPy must be imported in order to be available
		\begin{itemize}
			%\item By convention, \texttt{import numpy as np}
			\item Remember, you can use \texttt{np?} or \texttt{np.<TAB>}
		\end{itemize}

		The main component of NumPy is \alert{ndarray}
		\begin{itemize}
			\item Python object
			\item Efficient matrix representation
			\item Homogeneus elements
		\end{itemize}

 	   \column{0.4\textwidth}
		\begin{block}{\footnotesize{Convention}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			import numpy as np
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{block}

		\begin{exampleblock}{}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			In [1]: array = np.array([1,2,3])
			In [2]: array
			Out[1]: array([1, 2, 3])
			In [3]: array = np.array([[1,2],[3,4]])
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}

\end{frame}

\subsection{Matrix creation}
\begin{frame}[fragile]{NumPy}{Matrix creation}
	NumPy functions for array creation from lists
	\begin{itemize}
		\item Lists must contain the same type, NumPy will upcast if needed
		\item \texttt{np.array([1, 4, 2, 5, 3])}
		\item \texttt{np.array([1, 2, 3, 4], dtype='float32')}: Explicit data type
		\item \texttt{np.array([3.14, 4, 2, 3])}: Upcast
	\end{itemize}
	NumPy functions for array creation from scratch
	\begin{itemize}
		\item \texttt{np.zeros(10, dtype=int)}: All zeros
		\item \texttt{np.ones((3, 5), dtype=float)}: All ones
		\item \texttt{np.full((3, 5), 3.14)}: Fill matrix
		\item \texttt{np.arange(0, 20, 2)}: Similar to Python's range()
		\item \texttt{np.linspace(0, 1, 5)}: Evenly spaced numbers
		\item \texttt{np.random.random((3, 3))}: Random numbers
		\item \texttt{np.random.normal(0, 1, (3, 3))}: Random normal numbers
		\item \texttt{np.random.randint(0, 10, (3, 3))}: Random integers
		\item \texttt{np.eye(3)}: Identity matrix
		\item \texttt{np.empty(3)}: Empty matrix
	\end{itemize}
\end{frame}

\subsection{NumPy data types}
\begin{frame}[fragile]{NumPy}{NumPy data types}
	\begin{columns}
 	   \column{0.4\textwidth}
	   Python is implemented in C
	   \begin{itemize}
	   	\item Data types in NumPy are based on those in C
	   \end{itemize}
	   Two styles to declare types
	   \begin{itemize}
	   	\item String:\\ \texttt{np.zeros(10, dtype='int16')}
		\item NumPy object: \texttt{np.zeros(10, dtype=np.int16)}
	   \end{itemize}

 	   \column{0.6\textwidth}
	\footnotesize{
    \begin{tabular}{ll}\hline
       \textsc{Data type} &  \textsc{Description}\\ \hline
	   \texttt{bool\_} & Boolean (True or False) stored as a byte  \\
	   \texttt{int\_} & Default integer type  \\
	   \texttt{intc} & Identical to C  \\
	   \texttt{intp} & Integer used for indexing  \\
	   \texttt{int8} & Byte  \\
	   \texttt{int16} & Integer  \\
	   \texttt{int32} & Integer  \\
	   \texttt{int64} & Integer  \\
	   \texttt{uint8} & Unsigned integer  \\
	   \texttt{uint16} & Unsigned integer  \\
	   \texttt{uint32} & Unsigned integer  \\
	   \texttt{uint64} & Unsigned integer  \\
	   \texttt{float\_} & Shorthand for float64  \\
	   \texttt{float16} & Half precision float  \\
	   \texttt{float32} & Single precision float  \\
	   \texttt{float64} & Double precision float  \\
	   \texttt{complex\_} & Shorthand for complex128  \\
	   \texttt{complex64} & Complex number  \\
	   \texttt{complex128} & Complex number  \\\hline
    \end{tabular}
	}
	\end{columns}
\end{frame}

\subsection{NumPy array attributes}
\begin{frame}[fragile]{NumPy}{NumPy array attributes}
	\begin{columns}
 	   \column{0.5\textwidth}
		Ndarray objects expose several attributes
		\begin{itemize}
			\item \texttt{ndim}: Dimensions
			\item \texttt{shape}: Size of each dimension
			\item \texttt{size}: Number of elements
			\item \texttt{dtype}: Data type
			\item \texttt{itemsize}: Size of each element (in bytes)
			\item \texttt{nbytes}: Size of the array (in bytes)
		\end{itemize}

 	   \column{0.5\textwidth}
		\begin{exampleblock}{}
		\vspace{-0.2cm} 
			\begin{lstlisting}
x = np.random.randint(10, size=(3, 4))
print("x3 ndim: ", x3.ndim)
print("x3 shape:", x3.shape)
print("x3 size: ", x3.size)
print("dtype:", x3.dtype)
print("itemsize:", x3.itemsize, "bytes")
print("nbytes:", x3.nbytes, "bytes")
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\subsection{Accessing single elements}
\begin{frame}[fragile]{NumPy}{Accessing single elements}
	\begin{columns}
 	   \column{0.5\textwidth}
		Unidimensional array
		\begin{itemize}
			\item \texttt{array[index]}
		\end{itemize}
		Unidimensional array from the end
		\begin{itemize}
			\item \texttt{array[-index]}
		\end{itemize}
		Multidimensional array
		\begin{itemize}
			\item \texttt{array[row,column]}
		\end{itemize}

 	   \column{0.5\textwidth}
		\begin{exampleblock}{}
		\vspace{-0.2cm} 
			\begin{lstlisting}
x = np.array([5, 0, 3, 3, 7, 9])
x[0] # 5
x[4] # 7
x[-1] # 9
x[-2] # 7
x = np.array([[3, 5, 2, 4],
    [7, 6, 8, 8],
    [1, 6, 7, 7]])
x2[2, 0] # 1 
x2[2, -1] # 7
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}

	\smallskip

	\begin{columns}
 	   \column{0.6\textwidth}
		\begin{alertblock}{Warning}
			Ndarray has fixed types, values can be truncaded without warning. Big source of problems!
		\end{alertblock}
	\end{columns}

\end{frame}

\subsection{Accessing subarrays}
\begin{frame}[fragile]{NumPy}{Accessing subarrays}
	\begin{columns}
 	   \column{0.5\textwidth}
		Slice notation can be used with ndarray
		\begin{itemize}
			\item \texttt{x[start:stop:step]}
		\end{itemize}
		Default values
		\begin{itemize}
			\item Start = 0
			\item Stop = Size of dimension
			\item Step = 1
		\end{itemize}
		Step may take a negative value
		\begin{itemize}
			\item Reverse order
		\end{itemize}
		These operations return a view 
		\begin{itemize}
			\item Use \texttt{copy()} to get a copy
		\end{itemize}

 	   \column{0.5\textwidth}
		\begin{exampleblock}{\footnotesize{Unidimensional array}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
x[:5]   # first five elements
x[5:]   # elements after index 5
x[4:7]  # middle sub-array
x[::2]  # every other element
x[1::2] # every other element, starting at index 1
x[::-1] # all elements, reversed
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}

		\begin{exampleblock}{\footnotesize{Multidimensional a  rray}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
x[:2, :3]  # 2 rows, 3 columns
x[:3, ::2] # all rows, every other column
x[::-1, ::-1]
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\subsection{Reshaping of arrays}
\begin{frame}[fragile]{NumPy}{Reshaping of arrays}
	\begin{columns}
 	   \column{0.5\textwidth}
		Reshaping arrays is a very common task
		\begin{itemize}
			\item Change data number of dimensions
			% Ejemplo imagen en red neuronal
		\end{itemize}
		Important ndarray method: \texttt{reshape()}
		\begin{itemize}
			\item Changes the dimensions of an array
			\item Sizes must match
		\end{itemize}

 	   \column{0.5\textwidth}
		\begin{exampleblock}{\footnotesize{General reshaping}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
In [1]: x=np.array([1, 2, 3, 4])
In [2]: x.reshape((2,2))
Out[1]: 
array([[1, 2],
       [3, 4]])
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}

	\begin{columns}
	   \column{0.5\textwidth}
		Conversion of 1-D arrays into column or row matrices
		\begin{itemize}
			\item Using method \texttt{reshape()}
			\item Using the keyword \alert{np.newaxis}
		\end{itemize}

 	   \column{0.5\textwidth}
		\begin{exampleblock}{\footnotesize{1-D to row}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
x = np.array([1, 2, 3])
x.reshape((1, 3))
x[np.newaxis, :]
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}

		\begin{exampleblock}{\footnotesize{1-D to column}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
x.reshape((3, 1))
x[:, np.newaxis]
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\subsection{Concatenation of arrays}
\begin{frame}[fragile]{NumPy}{Concatenation of arrays}
	\begin{columns}
 	   \column{0.4\textwidth}
		Three methods to join arrays
		\begin{itemize}
			\item \texttt{np.concatenate()}
			\item \texttt{np.vstack()}
			\item \texttt{np.hstack()}
		\end{itemize}

 	   \column{0.6\textwidth}
		\begin{exampleblock}{\footnotesize{np.concatenate()}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
In [1]: x = np.array([1, 2, 3])
In [2]: y = np.array([3, 2, 1])
In [3]: np.concatenate([x, y])
Out[1]: array([1, 2, 3, 3, 2, 1])
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}

		\begin{exampleblock}{\footnotesize{np.vstack()}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
In [1]: x = np.array([1, 2, 3])
In [2]: grid = np.array([[9, 8, 7],
   ...:                  [6, 5, 4]])
In [3]: np.vstack([x, grid])
Out[107]: 
array([[1, 2, 3],
       [9, 8, 7],
       [6, 5, 4]])
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\subsection{Splitting of arrays}
\begin{frame}[fragile]{NumPy}{Splitting of arrays}
	\begin{columns}
 	   \column{0.3\textwidth}
		Three methods to split arrays
		\begin{itemize}
			\item \texttt{np.split()}
			\item \texttt{np.vsplit()}
			\item \texttt{np.hsplit()}
		\end{itemize}

 	   \column{0.7\textwidth}
		\begin{exampleblock}{\footnotesize{np.split()}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			In [1]: x = [1, 2, 3, 99, 99, 3, 2, 1]
			In [2]: x1, x2, x3 = np.split(x, [3, 5])
			In [3]: print(x1, x2, x3)
			[1 2 3] [99 99] [3 2 1]
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}

		\begin{exampleblock}{\footnotesize{np.vstack()}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			In [1]: grid = np.arange(16).reshape((4, 4))
			In [2]: print(grid)
			[[ 0  1  2  3]
			 [ 4  5  6  7]
			 [ 8  9 10 11]
			 [12 13 14 15]]
			In [3]: upper, lower = np.vsplit(grid, [2])
			In [4]: print(upper)
			   [[0 1 2 3]
			    [4 5 6 7]]
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\subsection{Universal functions}
\begin{frame}[fragile]{NumPy}{Universal functions (I)}
	Python may be ridiculously slow
	\begin{itemize}
		\item Run-time type checks and function dispatching
		\item Evident when an operation is repeated over a collection of data
	\end{itemize}

	\vspace{-0.2cm} 
	\begin{columns}
 	   \column{0.8\textwidth}
		\begin{exampleblock}{\footnotesize{Performance test}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
def compute_reciprocals(values):
    output = np.empty(len(values))
    for i in range(len(values)):
        output[i] = 1.0 / values[i]
    return output

big_array = np.random.randint(1, 100, size=1000000)
# Stardand CPython
%timeit compute_reciprocals(big_array)
# 3.59 s ± 139 ms per loop 
# NumPy
%timeit (1.0 / big_array)
#5.41 ms ± 182 µs per loop
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\begin{frame}{NumPy}{Universal functions (II)}
	Vectorized operations: Functions that are aware of NumPy's static typing
	\begin{itemize}
		\item Avoid dynamic type-checking
		\item Loop related code pushed into the compiled layer
		\item Hugely improved performance
		\item Perform an operation with the first element and then it to the rest
	\end{itemize}
	In NumPy, vectoriced operations are named \alert{universal functions}, of \alert{ufuncs}
	\begin{itemize}
		\item Regular functions
		\item Arrays as arguments (one or multi-dimensional)
		\item Operates between arrays of different sizes (\alert{broadcasting})
	\end{itemize}
	In order to take advantange of NumPy's performance, ufuncs must be used
\end{frame}

\begin{frame}{NumPy}{Universal functions: Arithmetic functions}
	NumPy makes use of Python's native arithmetic operators
	\begin{itemize}
		\item Used like regular Python operators
		\item Operators are wrappers for NumPy's functions
	\end{itemize}

	\bigskip

	\footnotesize{
    \begin{tabular}{cll}\hline
       \textsc{Operator} & \textsc{Equivalent ufunc} & \textsc{Description}\\ \hline
	   \texttt{+} & \texttt{np.add} & Addition (e.g., 1 + 1 = 2) \\
	   \texttt{-} & \texttt{np.subtract} & Subtraction (e.g., 3 - 2 = 1)\\
	   \texttt{-} & \texttt{np.negative} & Unary negation (e.g., -2)\\
	   \texttt{*} & \texttt{np.multiply} & Multiplication (e.g., 2 * 3 = 6)\\
	   \texttt{/} & \texttt{np.divide} & Division (e.g., 3 / 2 = 1.5)\\
	   \texttt{//} & \texttt{np.floor\_divide} & Floor division (e.g., 3 // 2 = 1) \\
	   \texttt{**} & \texttt{np.power} & Exponentiation (e.g., 2 ** 3 = 8)\\
	   \texttt{\%} & \texttt{np.mod} & Modulus/remainder (e.g., 9 \% 4 = 1) \\\hline
    \end{tabular}
	}
\end{frame}

\begin{frame}[fragile]{NumPy}{Universal functions (III)}
	\vspace{-0.2cm} 
	\begin{columns}
 	   \column{0.8\textwidth}
		\begin{exampleblock}{\footnotesize{Binary ufuncs}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
x = np.arange(4)
print("x     =", x)
print("x + 5 =", x + 5)
print("x - 5 =", x - 5)
print("x * 2 =", x * 2)
print("x / 2 =", x / 2)
print("x // 2 =", x // 2)  # floor division
np.add(x, 2)               # array plus scalar
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}

		\begin{exampleblock}{\footnotesize{Unary ufuncs}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
print("-x     = ", -x)
print("x ** 2 = ", x ** 2)
print("x % 2  = ", x % 2)
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\begin{frame}{NumPy}{Universal functions: Basic functions}
	Absolute value
	\begin{itemize}
		\item \texttt{np.absolute(x)} and \texttt{np.absolute(x)}
	\end{itemize}
	Trigonometric functions
	\begin{itemize}
		\item \texttt{np.sin(theta)}, \texttt{np.cos(theta)}, \texttt{np.tan(theta)}
		\item \texttt{np.arcsin(theta)}, \texttt{np.arccos(theta)}, \texttt{np.arctan(theta)}
	\end{itemize}
	Exponents and logarithms
	\begin{itemize}
		\item \texttt{np.exp(x)}, \texttt{np.exp2(x)}, \texttt{np.power(base, x)}
		\item \texttt{np.log(x)}, \texttt{np.log2(x)}, \texttt{np.log10(x)}
	\end{itemize}
	Advanced mathematical functions
	\begin{itemize}
		\item Checkout module \texttt{scipy.special} for exotic mathematical functions
	\end{itemize}
	Output as argument
	\begin{itemize}
		\item Avoid temporal variables using \texttt{out} argument in ufuncs
		\item Example: \texttt{np.multiply(x, 10, out=y)} 
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{NumPy}{Universal functions: Special functions}
	\vspace{-0.2cm} 
	\begin{columns}
 	   \column{0.5\textwidth}
			Aggregation functions
			\begin{itemize}
				\item Applied to any ufunc
				\item \texttt{reduce(x)}: Repeatedly applies an ufunc to the elements of an array until only a single result remains
				\item \texttt{accumulate(x)}: Like \texttt{reduce()}, but it stores intermediate values
				\item \texttt{outer(x)}: Compute the output of all pairs of two different inputs
			\end{itemize}

 	   \column{0.5\textwidth}
		\begin{exampleblock}{\footnotesize{reduce() example}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			In [1]: x = np.arange(1, 6)
			In [2]: np.add.reduce(x)
			Out[1]: 15
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}

		\begin{exampleblock}{\footnotesize{accumulate() example}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			In [1]: np.add.reduce(x)
			Out[1]: 15
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}

		\begin{exampleblock}{\footnotesize{Outer() example}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			In [132]:np.multiply.outer(x, x)
			array([[ 1,  2,  3,  4,  5], 
			       [ 2,  4,  6,  8, 10], 
			       [ 3,  6,  9, 12, 15], 
			       [ 4,  8, 12, 16, 20], 
			       [ 5, 10, 15, 20, 25]])
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\subsection{Aggregations}
\begin{frame}{NumPy}{Universal functions: Aggregations (I)}
	Many ufuncs to summarize data
	\begin{itemize}
		\item Basic step in exploratory data analysis
		\item Argument \texttt{axis} determines to which dimension the summary is to be applied
	\end{itemize}

	\smallskip

	\footnotesize{
    \begin{tabular}{lll}\hline
       \textsc{Function} & \textsc{NaN-safe version} & \textsc{Description}\\ \hline
	   \texttt{np.sum} & \texttt{np.nansum} & Compute sum of elements \\
	   \texttt{np.prod} & \texttt{np.nanprod} & Compute product of elements \\
	   \texttt{np.mean} & \texttt{np.nanmean} & Compute mean of elements \\
	   \texttt{np.std} & \texttt{np.nanstd} & Compute standard deviation \\
	   \texttt{np.var} & \texttt{np.nanvar} & Compute standard deviation \\
	   \texttt{np.min} & \texttt{np.nanmin} & Find minimum value \\
	   \texttt{np.max} & \texttt{np.nanmax} & Find maximum value \\
	   \texttt{np.argmin} & \texttt{np.nanargmin} & Find index of minimum value \\
	   \texttt{np.argmax} & \texttt{np.nanargmax} & Find index of maximum value \\
	   \texttt{np.median} & \texttt{np.nanmedian} & Compute median of elements \\
	   \texttt{np.percentile} & \texttt{np.nanpercentile} & Compute rank-based statistics of elements \\
	   \texttt{np.any} & \texttt{N/A} & Evaluate whether any elements are true \\
	   \texttt{np.all} & \texttt{N/A} & Evaluate whether all elements are true \\\hline
    \end{tabular}
	}
\end{frame}

\begin{frame}[fragile]{NumPy}{Universal functions: Aggregations (II)}
	\href{https://raw.githubusercontent.com/jakevdp/PythonDataScienceHandbook/master/notebooks/data/president\_heights.csv}{(Download dataset)}
	\begin{itemize}
		\item Use wget or curl to download the file within iPython
	\end{itemize}
	\vspace{-0.2cm} 
	\begin{columns}
 	   \column{0.9\textwidth}
		\begin{exampleblock}{\footnotesize{Basic data analysis example}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
	 import pandas as pd
	 data = pd.read_csv('president_heights.csv')
	 heights = np.array(data['height(cm)'])
	 print(heights)

	 print("Mean height:       ", heights.mean())
	 print("Standard deviation:", heights.std())
	 print("Minimum height:    ", heights.min())
	 print("Maximum height:    ", heights.max())

	 print("25th percentile:   ", np.percentile(heights, 25))
	 print("Median:            ", np.median(heights))
	 print("75th percentile:   ", np.percentile(heights, 75))
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}

\end{frame}

\begin{frame}[fragile]{NumPy}{Universal functions: Aggregations (III)}
	\vspace{-0.2cm} 
	\begin{columns}
 	   \column{0.9\textwidth}
		\begin{exampleblock}{\footnotesize{Basic data analysis example (Continuation)}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			%matplotlib inline
			import matplotlib.pyplot as plt
			import seaborn; seaborn.set()  # set plot style

			plt.hist(heights)
			plt.title('Height Distribution of US Presidents')
			plt.xlabel('height (cm)')
			plt.ylabel('number');
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}

	\centering \includegraphics[width=0.4\textwidth]{figs/presidents.pdf}	
\end{frame}

\subsection{Broadcasting}
\begin{frame}[fragile]{NumPy}{Universal functions: Broadcasting (I)}
	Broadcasting is a mechanism to operate over arrays of different sizes
	\begin{itemize}
		\item Used in ufuncs
		\item Implicit array expansion through three rules
	\end{itemize}
	\vspace{-0.2cm} 
	\begin{columns}
 	   \column{0.9\textwidth}
		\begin{block}{\footnotesize{Broadcasting rules}}
		\vspace{-0.2cm} 
		\begin{enumerate}
		\item Rule 1: If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side.
		\item Rule 2: If the shape of the two arrays does not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape.
		\item Rule 3: If in any dimension the sizes disagree and neither is equal to 1, an error is raised.
		\end{enumerate}
		\vspace{-0.2cm} 
		\end{block}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{NumPy}{Universal functions: Broadcasting (II)}
	\vspace{-0.2cm} 
	\begin{columns}
 	   \column{0.7\textwidth}
		\centering \includegraphics[width=\textwidth]{figs/02.05-broadcasting.png}	
 	   \column{0.3\textwidth}
	   	Array expansion does not consume memory!
	\end{columns}
\end{frame}

\begin{frame}[fragile]{NumPy}{Universal functions: Broadcasting (III)}
	\vspace{-0.2cm} 
	\begin{columns}
 	   \column{0.7\textwidth}
		\begin{exampleblock}{Normalization}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			X = np.random.random((10, 3))
			Xmean = X.mean(0)
			X_centered = X - Xmean
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}

		\begin{exampleblock}{3D plot}
		\vspace{-0.2cm} 
			\begin{lstlisting}[language=Python]
			%matplotlib inline
			import matplotlib.pyplot as plt

			x = np.linspace(0, 5, 50)
			y = np.linspace(0, 5, 50)[:, np.newaxis]
			z = np.sin(x)**10+np.cos(10+y*x)*np.cos(x)

			plt.imshow(z, origin='lower', 
			    extent=[0, 5, 0, 5], cmap='viridis')
			plt.colorbar();
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}

 	   \column{0.3\textwidth}
			\includegraphics[width=\textwidth]{figs/3dplot.pdf}	
	\end{columns}
\end{frame}

\begin{frame}[fragile]{NumPy}{Comparisons, masks, and Boolean logic (I)}
	\vspace{-0.2cm} 
	\begin{columns}
 	   \column{0.9\textwidth}
		\href{https://raw.githubusercontent.com/jakevdp/PythonDataScienceHandbook/master/notebooks/data/Seattle2014.csv}{(Download dataset)}
		\begin{exampleblock}{Example}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			import numpy as np
			import pandas as pd
             
			# pandas to extract rainfall inches as a ndarray
			rainfall = pd.read_csv('Seattle2014.csv')['PRCP'].values
			inches = rainfall / 254.0  # 1/10mm -> inches
			inches.shape 
			# Outputs (365,)
			 
			%matplotlib 
			import matplotlib.pyplot as plt
			import seaborn; seaborn.set()
			plt.hist(inches, 40);
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{NumPy}{Comparisons, masks, and Boolean logic (II)}
	\begin{columns}
 	   \column{0.4\textwidth}
		\includegraphics[width=\textwidth]{figs/rain.pdf}	
	\end{columns}

	Data filtering is a recurrent task
	\begin{itemize}
		\item How many rainy days were there in the year?
		\item What is the average precipitation on those rainy days?
		\item How many days were there with more than half an inch of rain?
	\end{itemize}

	Two filtering methods in NumPy
	\begin{itemize}
		\item Boolean arrays masks
		\item Fancy indexing
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{NumPy}{Comparisons, masks, and Boolean logic: Booleans arrays masks (I)}
	
	\begin{columns}
 	   \column{0.3\textwidth}
		\begin{exampleblock}{\footnotesize{Syntax examples}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
				x[x<5]
				x[x==3]
				x[(x>3)&(x<=5)]
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}

	\bigskip

	We've seen arithmetic ufuncs ...
	\begin{itemize}
		\item ... but they also support comparison and boolean operations
		\item Return an array of booleans
	\end{itemize}

	\footnotesize{
	\begin{columns}
 	   \column{0.5\textwidth}
       \begin{tabular}{ll}\hline
       	\textsc{Operator} &  \textsc{Ufunc}\\ \hline
       	== & \texttt{np.equal}  \\
       	!= & \texttt{np.not\_equal}  \\
       	<  & \texttt{np.less}  \\
       	<= & \texttt{np.less\_equal}  \\
       	>  & \texttt{np.greater}  \\
       	>= & \texttt{np.greater\_equal}\\\hline
    	\end{tabular}

 	   \column{0.5\textwidth}
        \begin{tabular}{ll}\hline
       	\textsc{Operator} &  \textsc{Ufunc}\\ \hline
       	\& & \texttt{np.bitwise\_and} \\
       	|  & \texttt{np.bitwise\_or}  \\
       	\textasciicircum & \texttt{np.bitwise\_xor} \\
       	\textasciitilde & \texttt{np.bitwise\_not} \\\hline
    	\end{tabular}
	\end{columns}
	}
\end{frame}

\begin{frame}[fragile]{NumPy}{Comparisons, masks, and Boolean logic: Booleans arrays masks (II)}
	
	\begin{columns}
 	   \column{0.7\textwidth}
		\begin{exampleblock}{\footnotesize{Example}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
				print(x)
				[[5, 0, 3, 3]
				 [7, 9, 3, 5]
				 [2, 4, 7, 6]]
				np.count_nonzero(x < 6) # Returns 8
				np.sum(x < 6) # Returns 8
				np.sum(x < 6, axis=1) # By row, returns array([4,2,2])
				np.any(x > 8) # Returns True
				np.any(x < 0) # Returns False
				np.all(x < 10)# Returns True

				np.sum(~((inches <= 5) | (inches >= 1)))
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{NumPy}{Comparisons, masks, and Boolean logic: Fancy indexing}
	\begin{columns}
 	   \column{0.4\textwidth}
	So far we've seen three accessing methods
	\begin{itemize}
		\item Simple indices (\texttt{x[1]})
		\item Slices (\texttt{x[:5]})
		\item Boolean masks (\texttt{x[x>0]})
	\end{itemize}
	Fancy indexing: Pass arrays on indices instead of scalars
 	   \column{0.6\textwidth}
		\begin{exampleblock}{\footnotesize{Example}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
				x = rand.randint(100, size=10)
				[x[3], x[7], x[2]] # Simple indices
				ind = [3, 7, 4] # Array of indices
				x[ind] # Fancy indexing
				x[[3,5,6]] # Also valid
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}

		\footnotesize{
		\begin{alertblock}{}
		The shape of the result reflects the shape of the index arrays rather than the shape of the array being indexed
		\end{alertblock}
		}
	\end{columns}
\end{frame}

\subsection{Structured arrays}
\begin{frame}[fragile]{NumPy}{Structured arrays (I)}
	Some times, we need to group data
	\begin{itemize}
		\item Example: Store name, age and weight of several people
		\item Different data types for each attribute
	\end{itemize}
	\begin{columns}
 	   \column{\textwidth}
		\begin{exampleblock}{\footnotesize{Non-structured array}}
		\vspace{-0.2cm} 
		\begin{lstlisting}
			name = ['Alice', 'Bob', 'Cathy', 'Doug']
			age = [25, 45, 37, 19]
			weight = [55.0, 85.5, 68.0, 61.5]
		\end{lstlisting}
		\vspace{-0.2cm} 
	\end{exampleblock}
	
	\vspace{-0.2cm}
	\begin{flushleft}
	Solution: Structured arrays
	\end{flushleft}
	\vspace{-0.2cm}
	\begin{exampleblock}{\footnotesize{Structured arrays}}
		\vspace{-0.2cm} 
		\begin{lstlisting}
		# Use a compound data type for structured arrays
		data = np.zeros(4, dtype={'names':('name', 'age', 'weight'),
                          'formats':('U10', 'i4', 'f8')})
		\end{lstlisting}
		\vspace{-0.2cm} 
	\end{exampleblock}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{NumPy}{Structured arrays (II)}
	\begin{columns}
 	   \column{0.6\textwidth}
	\begin{exampleblock}{\footnotesize{Structured array manipulation}}
		\vspace{-0.2cm} 
		\begin{lstlisting}
		data['name'] = name
		data['age'] = age
		data['weight'] = weight

		# Get all names
		data['name']
		# Get first row of data
		data[0]
		# Get the name from the last row
		data[-1]['name']
		# Get names where age is under 30
		data[data['age'] < 30]['name']
		\end{lstlisting}
		\vspace{-0.2cm} 
	\end{exampleblock}

	\bigskip

	\end{columns}
	These kind of structures are day-to-day used
	\begin{itemize}
		\item Pandas is a much better choice
	\end{itemize}
\end{frame}


\section{Pandas}
\subsection{Introduction}

\begin{frame}[fragile]{Pandas}{Introduction}
	\begin{columns}
 	   \column{0.6\textwidth}

	A data science workflow needs more features
	\begin{itemize}
		\item Label columns and rows
		\item Missing data
		\item Operations on groups
		\item Data input
	\end{itemize}
	Pandas implements all those features, and more
	\begin{itemize}
		\item Built on NumPy's ndarray
	\end{itemize}
	Pandas provides two main objects
	\begin{itemize}
		\item \texttt{Series}
		\item \texttt{DataFrame}
	\end{itemize}

 	   \column{0.4\textwidth}
		\begin{block}{\footnotesize{Convention}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			import numpy as np
			import pandas as pd
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{block}
	\end{columns}
\end{frame}

\subsection{The Pandas \texttt{Series} object}
\begin{frame}[fragile]{Pandas}{Introduction}
	\begin{columns}
 	   \column{0.6\textwidth}
		A DS/ML workflow needs more features
		\begin{itemize}
			\item Missing data
			\item Data input
			\item Operations on groups
			\item Label columns and rows
		\end{itemize}
		Pandas provides all those features, and more
		\begin{itemize}
			\item Pandas = \textbf{PAN}el \textbf{DA}ta \textbf{S}ystem
			\item Built on NumPy's ndarray
			\item Provides \alert{dataframes}
		\end{itemize}
		Pandas provides two main objects
		\begin{itemize}
			\item \texttt{Series} and \texttt{DataFrame}
		\end{itemize}

 	   \column{0.4\textwidth}
		\includegraphics[width=\textwidth]{figs/pandas.png}	

		\begin{block}{\footnotesize{Convention}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			import numpy as np
			import pandas as pd
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{block}

	\end{columns}
\end{frame}

\begin{frame}[fragile]{Pandas}{The Pandas \texttt{Series} object (I)}
	\begin{columns}
 	   \column{0.6\textwidth}

	A \texttt{Series} is a one-dimensional array of indexed data
	\begin{itemize}
		\item NumPy arrays indices are implicit (i.e. its position)
		\item Series indices are explicit, and can be any type
	\end{itemize}
	Two attributes
	\begin{itemize}
		\item \texttt{values}: ndarray
		\item \texttt{index}: pd.Index object
	\end{itemize}
	Accessing through regular Python syntax

 	   \column{0.4\textwidth}
		\begin{exampleblock}{}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			data = pd.Series([0.25, 0.5, 0.75, 1.0])
			data.values
			data.index
			data[1:3]
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Pandas}{The Pandas \texttt{Series} object (II)}
	\begin{columns}
 	   \column{0.8\textwidth}
		\begin{exampleblock}{\footnotesize{Custom indices}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
			In[1] : data = pd.Series([0.25, 0.5, 0.75, 1.0],
			                   index=['a', 'b', 'c', 'd'])
			In [2]: data
			Out[1]: 
			a    0.25
			b    0.50
			c    0.75
			d    1.00
			dtype: float64

			In [3]: data['a']
			Out[2]: 0.25
			In [4]: data[0]
			Out[3]: 0.25
			\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\subsection{The Pandas \texttt{DataFrame} object}
\begin{frame}{Pandas}{The Pandas \texttt{DataFrame} object (I)}
	\begin{columns}
 	   \column{0.6\textwidth}
		A \texttt{DataFrame} is a 2-D tabular data structure
		\begin{itemize}
			\item Similar to a spreadsheet
			\item Homogeneous columns
			\item Heterogeneous rows
		\end{itemize}
		Two attributes, both \texttt{pd.Index}
		\begin{itemize}
			\item \texttt{index}: Rows
			\item \texttt{columns}: Columns
		\end{itemize}

 	   \column{0.4\textwidth}
		\centering \includegraphics[width=\textwidth]{figs/structure_table.jpg}\\
		\tiny \href{https://www.tutorialspoint.com/python\_pandas/python\_pandas\_dataframe.htm}{(Source)}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Pandas}{The Pandas \texttt{DataFrame} object (II)}
	\begin{columns}
 	   \column{\textwidth}
		\begin{exampleblock}{\footnotesize{DataFrame example}}
		\vspace{-0.2cm} 
			\begin{lstlisting}
In [1]:  import seaborn as sns

In [2]:  iris = sns.load_dataset('iris')
In [3]:  iris.head()

Out[1]:
sepal_length  sepal_width  petal_length  petal_width species
0           5.1          3.5           1.4          0.2  setosa
1           4.9          3.0           1.4          0.2  setosa
2           4.7          3.2           1.3          0.2  setosa
3           4.6          3.1           1.5          0.2  setosa
4           5.0          3.6           1.4          0.2  setosa
In [246]: iris.columns
Out[246]: 
Index(['sepal_length', 'sepal_width', 'petal_length', 'petal_width', 'species'],
	    dtype='object')
		\end{lstlisting}
		\vspace{-0.2cm} 
		\end{exampleblock}
	\end{columns}
\end{frame}

\subsection{Constructing \texttt{DataFrame} objects}
\begin{frame}[fragile]{Pandas}{Constructing \texttt{DataFrame} objects}
	Manual initialization
	\begin{itemize}
		\item From a single \texttt{Series} object\\
		\texttt{pd.DataFrame(population, columns=['population'])}
		\item From several \texttt{Series} objects\\
		\texttt{pd.DataFrame({'population': population,
		                       'area': area})}
		\item From a dictionary\\
	    \texttt{pd.DataFrame([\{'a': 0, 'b': 0\}, \{'a': 1, 'b': 2\}])}
		\item From a NumPy 2-D array\\
		\texttt{pd.DataFrame(np.random.rand(3, 2), \\columns=['foo', 'bar'], index=['a', 'b', 'c'])}
	\end{itemize}
	Read from a file
	\begin{itemize}
		\item CSV (very common!!!): \texttt{pd.read\_csv('filename.csv')}
		\item Excel:\\
		\texttt{pd.read\_excel('filename.xlsx', sheetname='mysheet')}
	\end{itemize}
\end{frame}

\section{Matplotlib}
\section{Seaborn}



%\begin{frame}[plain]{Solved exercise. Serializando objetos \texttt{Parcela}}{}
%	\vspace{-0.4cm}
  %  \begin{columns}
 %	   \column{0.8\textwidth}
%			\begin{block}{\footnotesize{tasaparcela\_pickle.py}}
%			\vspace{-0.2cm} 
%				\lstinputlisting[basicstyle=\ttfamily\scriptsize]{code/tasaparcela_pickle.py} % contar elementos
%			\vspace{-0.2cm} 
%			\end{block}
%	\end{columns}
	
%\end{frame}


\end{document}
